/*
 * Copyright 2018 Martin Ã…berg
 *
 * This file is part of Footag.
 *
 * Footag is free software: you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation, either version 3 of the License, or (at your option) any later
 * version.
 *
 * Footag is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program. If not, see <http://www.gnu.org/licenses/>.
 */

#include <footag/fout_horizon.h>
#include <errno.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <uuid/uuid.h>
#include "fout_priv.h"
#include "footlist.h"
#include "footson.h"

/*
 * We provide our own padstacks which are used all packages generated by this
 * output module.
 *
 * The provided are based on horizon-pool.git (ca259a) but have their own
 * UUIDs. That means the generated packages do not depend on any particular
 * external pool database being available.
 *
 * You can add them to your pool by soft-linking the directory
 * misc/horizon-padstacks somewhere in the $(pool)/padstacks.
 */
static const char *HPADSTACK[GEOM_PAD_NUM] = {
        [GEOM_PAD_RECT]         = "ed01c9aa-becb-4201-b725-87b8de64e95d",
        [GEOM_PAD_RRECT]        = "cbfd97fb-8587-4f57-9e64-71973626ba4a",
        [GEOM_PAD_CIRC]         = "ec94a1d2-4f50-4b9b-a7eb-581f6518dceb",
        [GEOM_PAD_TRECT]        = "ab75b071-e22e-4d27-b411-80d17af2262d",
        [GEOM_PAD_TCIRC]        = "488b2b09-18a9-4cdb-b54e-d41ca4b5a66c",
};

static const struct fout_ops THEOPS;

struct fout_horizon_ctx {
        struct fout_ctx fout;
        struct footson_ctx packs;
        struct footlist gfxjunc;
        double polyminx;
        double polyminy;
        const char *name;
};

struct hjunc {
        struct footnode node;
        uuid_t uuid;
        long x, y;
};
struct layermagic {
        int index;
        const char *name;
};

/* Mapping from layer to index extracted from horizon/src/pool/package.cpp. */
static const struct layermagic LAYERMAGIC[GEOM_LAYER_NUM] = {
        [GEOM_LAYER_CYARD]      = {  60, "Top Courtyard"},
        [GEOM_LAYER_COPPER]     = {   0, "Top Copper"},
        [GEOM_LAYER_SILK]       = {  20, "Top Silkscreen"},
        [GEOM_LAYER_ASSY]       = {  50, "Top Assembly"},
#if SUPPORT_FOR_HORIZON_PACKAGE_LAYER
        [WHATEVER]              = {  40, "Top Package"},
#endif
};

static long mmtodev(double mm)
{
        return round(mm * 1000 * 1000);
}

static int fprintuuid(struct footson_ctx *ctx)
{
        uuid_t myuuid;
        char str[36 + 1];
        uuid_generate_random(myuuid);
        uuid_unparse(myuuid, str);
        fprintf(ctx->stream, "\"%s\"", str);
        return FOUT_OK;
}

static int douuid(struct footson_ctx *ctx)
{
        char str[36 + 1];
        uuid_t myuuid;
        uuid_generate_random(myuuid);
        uuid_unparse(myuuid, str);
        footson_addmember(ctx, str);
        return FOUT_OK;
}

static int domm(struct footson_ctx *ctx, const char *name, double mm)
{
        footson_dolong(ctx, name, mmtodev(mm));
        return FOUT_OK;
}

static struct hjunc *add_junc(struct fout_horizon_ctx *ctx, double x, double y)
{
        struct hjunc *junc;
        junc = calloc(1, sizeof *junc);
        if (!junc) { return NULL; }
        uuid_generate_random(junc->uuid);
        junc->x = mmtodev(x);
        junc->y = mmtodev(y);
        footlist_add(&ctx->gfxjunc, &junc->node);
        return junc;
}

static int emit_line_or_arc(
        struct fout_horizon_ctx *ctx,
        uuid_t *from,
        uuid_t *to,
        uuid_t *center,
        int layer,
        double linew
)
{
        char str[36 + 1];

        douuid(&ctx->packs);
        footson_push(&ctx->packs, "{");
        {
                uuid_unparse(*from, str);
                footson_dostring(&ctx->packs, "from", str);
                uuid_unparse(*to, str);
                footson_dostring(&ctx->packs, "to", str);
                if (center) {
                        uuid_unparse(*center, str);
                        footson_dostring(&ctx->packs, "center", str);
                }
                footson_dolong(&ctx->packs, "layer", LAYERMAGIC[layer].index);
                domm(&ctx->packs, "width", linew);
        }
        footson_pop(&ctx->packs, "}");

        return FOUT_OK;
}

static int add_gfxrect(
        struct fout_horizon_ctx *ctx,
        const struct geom_rect *r,
        int layer,
        double linew
)
{
        int ret = FOUT_OK;
        struct hjunc *junc[4];

        for (int i = 0; i < 4; i++) {
                junc[i] = add_junc(ctx, 0, 0);
                if (!junc[i]) { return FOUT_FAIL; }
        }
        junc[0]->x = mmtodev(r->x);        junc[0]->y = mmtodev(r->y);
        junc[1]->x = mmtodev(r->x);        junc[1]->y = mmtodev(r->y + r->h);
        junc[2]->x = mmtodev(r->x + r->w); junc[2]->y = mmtodev(r->y + r->h);
        junc[3]->x = mmtodev(r->x + r->w); junc[3]->y = mmtodev(r->y);

        for (int i = 0; i < 4; i++) {
                ret = emit_line_or_arc(
                        ctx,
                        &junc[i]->uuid,
                        &junc[(i+1)%4]->uuid,
                        NULL,
                        layer,
                        linew
                );
                if (ret) { break; }
        }
        return ret;
}

static int add_gfxline(
        struct fout_horizon_ctx *ctx,
        const struct geom_line *r,
        int layer,
        double linew
)
{
        int ret = FOUT_OK;
        struct hjunc *junc[2];

        junc[0] = add_junc(ctx, r->x0, r->y0);
        if (!junc[0]) { return FOUT_FAIL; }
        junc[1] = add_junc(ctx, r->x1, r->y1);
        if (!junc[1]) { return FOUT_FAIL; }

        ret = emit_line_or_arc(
                ctx,
                &junc[0]->uuid,
                &junc[1]->uuid,
                NULL,
                layer,
                linew
        );

        return ret;
}

/* construct circle with two half circle arcs */
static int add_gfxcircle(
        struct fout_horizon_ctx *ctx,
        const struct geom_circle *r,
        int layer,
        double linew
)
{
        int ret = FOUT_OK;
        struct hjunc *junc[3];

        junc[0] = add_junc(ctx, r->x - r->r, r->y);
        if (!junc[0]) { return FOUT_FAIL; }
        junc[1] = add_junc(ctx, r->x + r->r, r->y);
        if (!junc[1]) { return FOUT_FAIL; }
        junc[2] = add_junc(ctx, r->x, r->y);
        if (!junc[2]) { return FOUT_FAIL; }

        for (int i = 0; i < 2; i++) {
                ret = emit_line_or_arc(
                        ctx,
                        &junc[i]->uuid,
                        &junc[!i]->uuid,
                        &junc[2]->uuid,
                        layer,
                        linew
                );
                if (ret) { break; }
        }
        return ret;
}

static int dotags(struct fout_horizon_ctx *ctx)
{
        footson_addmember(&ctx->packs, "tags");
        footson_push(&ctx->packs, "[");
        if (1) {
                footson_addstring(&ctx->packs, "footag");
        }
        footson_pop(&ctx->packs, "]");
        return FOUT_OK;
}

static int emitplacement(
        struct footson_ctx *ctx,
        double x,
        double y
)
{
        footson_addmember(ctx, "placement");
        footson_push(ctx, "{");
        {
                footson_dolong(ctx, "angle", 0);
                footson_dobool(ctx, "mirror", 0);
                footson_addmember(ctx, "shift");
                fprintf(ctx->stream, "[ %ld, %ld ]", mmtodev(x), mmtodev(y));
        }
        footson_pop(ctx, "}");
        return FOUT_OK;
}

static int emittext(
        struct fout_horizon_ctx *ctx,
        int layer,
        const char *text,
        double x,
        double y,
        double size,
        double width
)
{
        douuid(&ctx->packs);
        footson_push(&ctx->packs, "{");
        {
                footson_dolong(&ctx->packs, "layer", LAYERMAGIC[layer].index);
                footson_dostring(&ctx->packs, "origin", "center");
                emitplacement(&ctx->packs, x, y);
                domm(&ctx->packs, "size", size);
                footson_dostring(&ctx->packs, "text", text);
                domm(&ctx->packs, "width", width);
        }
        footson_pop(&ctx->packs, "}");
        return FOUT_OK;
}

/* Emit reference designator on silk and assy */
static int emittexts(struct fout_horizon_ctx *ctx)
{
        footson_addmember(&ctx->packs, "texts");
        footson_push(&ctx->packs, "{");
        {
                /* place refdes outside courtyard */
                double silkx = ceil(ctx->polyminx / 0.1) * 0.1;
                double silky = floor((ctx->polyminy - 2.0 / 2) / 0.1) * 0.1;
                emittext(ctx, GEOM_LAYER_SILK, "$RD", silkx, silky, 1.5, 0.15);
                emittext(ctx, GEOM_LAYER_ASSY, "$RD", 0, 0, 1, 0);
        }
        footson_pop(&ctx->packs, "}");
        return FOUT_OK;
}

static int emitpos(struct footson_ctx *ctx, long x, long y)
{
        footson_addmember(ctx, "position");
        fprintf(ctx->stream, "[ %ld, %ld ]", x, y);
        return FOUT_OK;
}

static int emitjunctions(struct fout_horizon_ctx *ctx)
{
        const struct hjunc *junc = (const struct hjunc *) ctx->gfxjunc.head;
        footson_addmember(&ctx->packs, "junctions");
        footson_push(&ctx->packs, "{");
        while (junc) {
                char str[36 + 1];
                uuid_unparse(junc->uuid, str);
                footson_addmember(&ctx->packs, str);
                footson_push(&ctx->packs, "{");
                {
                        emitpos(&ctx->packs, junc->x, junc->y);
                }
                footson_pop(&ctx->packs, "}");
                junc = (const struct hjunc *) junc->node.next;
        }
        footson_pop(&ctx->packs, "}");

        return FOUT_OK;
}

static int islineson(const struct geom_shape *shape)
{
        return (
                shape->layer != GEOM_LAYER_CYARD &&
                shape->layer != GEOM_LAYER_COPPER &&
                (
                        shape->type == GEOM_SHAPE_RECT ||
                        shape->type == GEOM_SHAPE_LINE
                )
        );
}

static int isarcson(const struct geom_shape *shape)
{
        return (
                shape->layer != GEOM_LAYER_CYARD &&
                shape->layer != GEOM_LAYER_COPPER &&
                shape->type == GEOM_SHAPE_CIRCLE
        );
}

static int ispadson(const struct geom_shape *shape)
{
        return (shape->type == GEOM_SHAPE_PAD);
}

static int ispolygonson(const struct geom_shape *shape)
{
        return (shape->layer == GEOM_LAYER_CYARD);
}

static int emitpad(struct fout_horizon_ctx *ctx, const struct geom_pad *pad)
{
        douuid(&ctx->packs);
        footson_push(&ctx->packs, "{");
        footson_dostring(&ctx->packs, "name", pad->name);
        footson_dostring(&ctx->packs, "padstack", HPADSTACK[pad->type]);

        /* Horizon parameter programs are awesome! */
        footson_addmember(&ctx->packs, "parameter_set");
        footson_push(&ctx->packs, "{");
        {
                domm(&ctx->packs, "pad_height", pad->h);
                domm(&ctx->packs, "pad_width", pad->w);
                domm(&ctx->packs, "corner_radius", pad->param);
                domm(&ctx->packs, "pad_diameter", pad->w);
                domm(&ctx->packs, "hole_diameter", pad->holew);
        }
        footson_pop(&ctx->packs, "}");
        emitplacement(&ctx->packs, pad->x, pad->y);
        footson_pop(&ctx->packs, "}");

        return FOUT_OK;
}

static int emitpads(struct fout_horizon_ctx *ctx, const struct geom_shape *head)
{
        int ret = FOUT_OK;
        const struct geom_shape *shape;

        footson_addmember(&ctx->packs, "pads");
        footson_push(&ctx->packs, "{");

        for (shape = head; shape; shape = shape->next) {
                if (!ispadson(shape)) {
                        continue;
                }
                ret = emitpad(ctx, &shape->shape.pad);
                if (ret) { return ret; }
        }
        footson_pop(&ctx->packs, "}");
        return ret;
}

static int dogfxs(struct fout_horizon_ctx *ctx, const struct geom_shape *head)
{
        int ret = FOUT_OK;
        const struct geom_shape *s;

        footson_addmember(&ctx->packs, "lines");
        footson_push(&ctx->packs, "{");
        for (s = head; s && ret == FOUT_OK; s = s->next) {
                if (!islineson(s)) {
                        continue;
                }
                if (s->type == GEOM_SHAPE_LINE) {
                        ret = add_gfxline(
                                ctx,
                                &s->shape.line,
                                s->layer,
                                s->linew
                        );
                } else if (s->type == GEOM_SHAPE_RECT) {
                        ret = add_gfxrect(
                                ctx,
                                &s->shape.rect,
                                s->layer,
                                s->linew
                        );
                } else {
                        ret = FOUT_FAIL;
                }
        }
        footson_pop(&ctx->packs, "}");

        footson_addmember(&ctx->packs, "arcs");
        footson_push(&ctx->packs, "{");
        for (s = head; s && ret == FOUT_OK; s = s->next) {
                if (!isarcson(s)) {
                        continue;
                }
                ret = add_gfxcircle(
                        ctx,
                        &s->shape.circle,
                        s->layer,
                        s->linew
                );
        }
        footson_pop(&ctx->packs, "}");

        return ret;
}

static int dopolyvertex(
        struct fout_horizon_ctx *ctx,
        const char *type,
        double x,
        double y,
        double a0,
        double a1
)
{
        footson_openobj(&ctx->packs);
        footson_addmember(&ctx->packs, "arc_center");
        fprintf(ctx->packs.stream, "[ %ld, %ld ]", mmtodev(a0), mmtodev(a1));
        emitpos(&ctx->packs, mmtodev(x), mmtodev(y));
        footson_dostring(&ctx->packs, "type", type);
        footson_closeobj(&ctx->packs);
        ctx->polyminx = fmin(ctx->polyminx, x);
        ctx->polyminy = fmin(ctx->polyminy, y);
        return FOUT_OK;
}

static int dopolyline(struct fout_horizon_ctx *ctx, const struct geom_line *l)
{
        dopolyvertex(ctx, "line", l->x0, l->y0, 0, 0);
        dopolyvertex(ctx, "line", l->x1, l->y1, 0, 0);
        return FOUT_OK;
}

static int dopolyrect(struct fout_horizon_ctx *ctx, const struct geom_rect *r)
{
        dopolyvertex(ctx, "line", r->x,         r->y,           0, 0);
        dopolyvertex(ctx, "line", r->x,         r->y + r->h,    0, 0);
        dopolyvertex(ctx, "line", r->x + r->w,  r->y + r->h,    0, 0);
        dopolyvertex(ctx, "line", r->x + r->w,  r->y,           0, 0);
        return FOUT_OK;
}

static int dopolycircle(
        struct fout_horizon_ctx *ctx,
        const struct geom_circle *c
)
{
        dopolyvertex(ctx, "arc", c->x - c->r, c->y, c->x, c->y);
        dopolyvertex(ctx, "arc", c->x + c->r, c->y, c->x, c->y);
        return FOUT_OK;
}

/*
 * Polygons are emitted in-line. Graphical lines and pads are stored in lists
 * because their emission affect multiple JSON sections.
 */
static int dopolygon(struct fout_horizon_ctx *ctx, const struct geom_shape *s)
{
        int ret = FOUT_OK;

        douuid(&ctx->packs);
        footson_push(&ctx->packs, "{");

        /*
         * NOTE: The courtyard is determined by the GEOM and fixed. It is not a
         * parameter program.
         */
        footson_dolong(&ctx->packs, "layer", LAYERMAGIC[s->layer].index);
        footson_dostring(&ctx->packs, "parameter_class", "courtyard");
        footson_addmember(&ctx->packs, "vertices");
        footson_push(&ctx->packs, "[");

        if (s->type == GEOM_SHAPE_RECT) {
                dopolyrect(ctx, &s->shape.rect);
        } else if (s->type == GEOM_SHAPE_LINE) {
                dopolyline(ctx, &s->shape.line);
        } else if (s->type == GEOM_SHAPE_CIRCLE) {
                dopolycircle(ctx, &s->shape.circle);
        } else {
                ret = FOUT_FAIL;
        }
        footson_pop(&ctx->packs, "]");
        footson_pop(&ctx->packs, "}");

        return ret;
}

static int dopolygons(
        struct fout_horizon_ctx *ctx,
        const struct geom_shape *head
)
{
        int ret = FOUT_OK;
        const struct geom_shape *shape;
        footson_addmember(&ctx->packs, "polygons");
        footson_push(&ctx->packs, "{");
        for (shape = head; shape; shape = shape->next) {
                if (!ispolygonson(shape)) {
                        continue;
                }
                ret = dopolygon(ctx, shape);
                if (ret) { return ret; }
        }
        footson_pop(&ctx->packs, "}");
        return ret;
}

static int setname(struct fout_ctx *fout, const char *name)
{
        struct fout_horizon_ctx *ctx = (struct fout_horizon_ctx *) fout;

        ctx->name = name;
        return FOUT_OK;
}

static int pregen(struct fout_ctx *fout, const struct geom_shape *head)
{
        struct fout_horizon_ctx *ctx = (struct fout_horizon_ctx *) fout;

        footson_push(&ctx->packs, "{");
        footson_dostring(&ctx->packs, "type", "package");
        footson_dostring(&ctx->packs, "name", ctx->name);
        footson_addmember(&ctx->packs, "uuid"); fprintuuid(&ctx->packs);
        dotags(ctx);
        dopolygons(ctx, head);
        dogfxs(ctx, head);
        emitjunctions(ctx);
        emitpads(ctx, head);
        emittexts(ctx);
        footson_pop(&ctx->packs, "}\n");

        return FOUT_OK;
}

static int mkthedir(const char *dirname)
{
        int ret;
        ret = mkdir(dirname, S_IRWXU | S_IRWXG | S_IRWXO);
        if (ret == 0 || errno == EEXIST) {
                return 0;
        }
        return 1;
}

static int fini(struct fout_ctx *fout)
{
        struct fout_horizon_ctx *ctx = (struct fout_horizon_ctx *) fout;
        struct footnode *node;

        if (!ctx) {
                return FOUT_OK;
        }
        if (ctx->packs.stream) {
                fclose(ctx->packs.stream);
        }
        while ((node = footlist_rem(&ctx->gfxjunc))) {
                free(node);
        }

        free(ctx);

        return FOUT_OK;
}

struct fout_ctx *fout_horizon_open(const char *dirname)
{
        int ret;
        struct fout_horizon_ctx *ctx;
        char *packname = NULL;

        ctx = calloc(1, sizeof *ctx);
        if (!ctx) {
                goto out;
        }

        ctx->polyminx = 0;
        ctx->polyminy = 0;
        footlist_init(&ctx->gfxjunc);
        footson_init(&ctx->packs);
        ctx->fout.ops = &THEOPS;

        {
                size_t namelen;

                if (NULL == dirname || 0 == strlen(dirname)) {
                        dirname = ".";
                }

                /* $dirname/package.json file name */
                namelen = strlen(dirname) + strlen("/package.json") + 1;
                packname = calloc(namelen, sizeof (char));
                if (!packname) {
                        goto out;
                }
                snprintf(packname, namelen, "%s/package.json", dirname);
        }

        ret = mkthedir(dirname);
        if (ret) {
                fprintf(
                        stderr,
                        "fout_horizon: %s: %s\n",
                        dirname,
                        strerror(errno)
                );
                goto out;
        }

        ctx->packs.stream = fopen(packname, "w");
        if (!ctx->packs.stream) {
                fprintf(
                        stderr,
                        "fout_horizon: %s: %s\n",
                        packname,
                        strerror(errno)
                );
                goto out;
        }
        free(packname);

        return &ctx->fout;

out:
        fini(&ctx->fout);
        return NULL;
}

static const struct fout_ops THEOPS = {
        .desc           = "horizon",
        .fini           = fini,
        .setname        = setname,
        .pregen         = pregen,
        .postgen        = fout_gen_none,
        .prelayer       = fout_layer_none,
        .postlayer      = fout_layer_none,
        .doshape        = fout_gen_none,
};

